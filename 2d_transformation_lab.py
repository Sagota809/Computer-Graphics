# -*- coding: utf-8 -*-
"""2D Transformation lab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K0AWeuSm4TfcXqtfziag7uhSrkkrDQX0

2D Translation:

Given a circle C with radius 10 and center coordinates (1,4).Apply the translation with distance 5 towards X-axis and 1 towards Y-axis.Obtain the new coordinates of C without changing its radius.
"""

import matplotlib.pyplot as plt

radius = 10
center_x, center_y = 1, 4

dx, dy = 5, 1

new_center_x = center_x + dx
new_center_y = center_y + dy

print(f"Original center: ({center_x}, {center_y}), radius: {radius}")
print(f"New center: ({new_center_x}, {new_center_y}), radius: {radius}")

fig, ax = plt.subplots()

ax.add_patch(plt.Circle((center_x, center_y), radius, fill=False, color='blue', label='Original'))
ax.add_patch(plt.Circle((new_center_x, new_center_y), radius, fill=False, color='red', linestyle='--', label='Translated'))

ax.plot(center_x, center_y, 'bo')
ax.plot(new_center_x, new_center_y, 'ro')

ax.set_aspect('equal')

plt.legend()
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.title("Circle Translation")
plt.grid(True)
plt.show()

"""Given a square with coordinate points A(0,3), B(3,3), C(3,0), and D(0,0).Apply the translation with distance 1 towards X-axis and 1 towards Y-axis. Obtain the new coordinates of the square."""

import matplotlib.pyplot as plt

A = (0, 3)
B = (3, 3)
C = (3, 0)
D = (0, 0)
square = [A, B, C, D, A]

dx, dy = 1, 1

translated_square = [(x + dx, y + dy) for x, y in square]

print("Original coordinates:", square[:-1])
print("Translated coordinates:", translated_square[:-1])

fig, ax = plt.subplots()

x_orig, y_orig = zip(*square)
ax.plot(x_orig, y_orig, 'b-', label='Original Square')
ax.scatter(*zip(*square[:-1]), color='blue')

x_new, y_new = zip(*translated_square)
ax.plot(x_new, y_new, 'r--', label='Translated Square')
ax.scatter(*zip(*translated_square[:-1]), color='red')

ax.set_aspect('equal')

plt.legend()
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.title("Square Translation")
plt.grid(True)
plt.show()

"""2D Scaling:

Given a square object with coordinate points A(0,3), B(3,3), C(3,0), and D(0,0).Applying the scaling parameter 2 towards X-axis and 3 towards Y-axis. Obtain the new coordinates of the object.
"""

import matplotlib.pyplot as plt

A = (0, 3)
B = (3, 3)
C = (3, 0)
D = (0, 0)
square = [A, B, C, D, A]

dx, dy = 1, 1

translated_square = [(x + dx, y + dy) for x, y in square]

print("Original coordinates:", square[:-1])
print("Translated coordinates:", translated_square[:-1])

fig, ax = plt.subplots()

x_orig, y_orig = zip(*square)
ax.plot(x_orig, y_orig, 'b-', label='Original Square')
ax.scatter(*zip(*square[:-1]), color='blue')

x_new, y_new = zip(*translated_square)
ax.plot(x_new, y_new, 'r--', label='Translated Square')
ax.scatter(*zip(*translated_square[:-1]), color='red')

ax.set_aspect('equal')

plt.legend()
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.title("Square Translation")
plt.grid(True)
plt.show()

"""2D Roation:

Given a line segment with starting pont at (0,0) and ending point at (4,4). Applying 30 degree rotation anti-colock wise direction on the line segment and find out new coordinates of the line.
"""

import matplotlib.pyplot as plt
import math

start = (0, 0)
end = (4, 4)
line = [start, end]

theta_deg = 30
theta_rad = math.radians(theta_deg)

# Rotation formula:
# x' = x*cosθ - y*sinθ
# y' = x*sinθ + y*cosθ
def rotate_point(x, y, angle_rad):
    x_new = x * math.cos(angle_rad) - y * math.sin(angle_rad)
    y_new = x * math.sin(angle_rad) + y * math.cos(angle_rad)
    return (x_new, y_new)

rotated_line = [rotate_point(x, y, theta_rad) for x, y in line]

print("Original line coordinates:", line)
print("Rotated line coordinates:", rotated_line)

fig, ax = plt.subplots()

x_orig, y_orig = zip(*line)
ax.plot(x_orig, y_orig, 'b-', label='Original Line', marker='o')

x_rot, y_rot = zip(*rotated_line)
ax.plot(x_rot, y_rot, 'r--', label='Rotated Line', marker='o')

ax.set_aspect('equal')

plt.legend()
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.title(f"Rotation of Line by {theta_deg}° Counterclockwise")
plt.grid(True)
plt.show()

"""Given a triangle with corner coordinates (0,0), (1,0), (1,1).Roated the triangle by 90 degree anti-clock wise direction and find the new coordinates."""

import matplotlib.pyplot as plt
import math

triangle = [(0, 0), (1, 0), (1, 1), (0, 0)]

# Rotation angle (90 degrees counterclockwise)
theta_deg = 90
theta_rad = math.radians(theta_deg)

# Rotation formula
def rotate_point(x, y, angle_rad):
    x_new = x * math.cos(angle_rad) - y * math.sin(angle_rad)
    y_new = x * math.sin(angle_rad) + y * math.cos(angle_rad)
    return (x_new, y_new)

rotated_triangle = [rotate_point(x, y, theta_rad) for x, y in triangle]

print("Original coordinates:", triangle[:-1])
print("Rotated coordinates:", rotated_triangle[:-1])

fig, ax = plt.subplots()

x_orig, y_orig = zip(*triangle)
ax.plot(x_orig, y_orig, 'b-', label='Original Triangle')
ax.scatter(*zip(*triangle[:-1]), color='blue')

x_rot, y_rot = zip(*rotated_triangle)
ax.plot(x_rot, y_rot, 'r--', label='Rotated Triangle')
ax.scatter(*zip(*rotated_triangle[:-1]), color='red')

ax.set_aspect('equal')

plt.legend()
plt.xlabel("X-axis")
plt.ylabel("Y-axis")
plt.title(f"Triangle Rotation by {theta_deg}° Counterclockwise")
plt.grid(True)
plt.show()

"""2D reflection:

Given a triangle with coordinate points A(3,4), B(6,4), C(5,6) apply the reflection on X-axis and obtain the new coordinate of the object.
"""

import matplotlib.pyplot as plt

# Original triangle coordinates
A = (3, 4)
B = (6, 4)
C = (5, 6)

# Function to reflect a point over the X-axis
def reflect_x(point):
    x, y = point
    return (x, -y)

A_ref = reflect_x(A)
B_ref = reflect_x(B)
C_ref = reflect_x(C)

original_x = [A[0], B[0], C[0], A[0]]
original_y = [A[1], B[1], C[1], A[1]]

reflected_x = [A_ref[0], B_ref[0], C_ref[0], A_ref[0]]
reflected_y = [A_ref[1], B_ref[1], C_ref[1], A_ref[1]]

plt.figure(figsize=(8, 6))
plt.plot(original_x, original_y, 'b-', label='Original Triangle')
plt.plot(reflected_x, reflected_y, 'r--', label='Reflected Triangle (X-axis)')

plt.scatter(*zip(A, B, C), color='blue')
plt.scatter(*zip(A_ref, B_ref, C_ref), color='red')

plt.axhline(0, color='black', linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5)
plt.grid(True)
plt.gca().set_aspect('equal', adjustable='box')
plt.legend()
plt.title("Reflection of Triangle Over X-axis")
plt.show()

"""Given a triangle with coordinate points A(3,4), B(6,4), C(5,6) apply the reflection on Y-axis and obtain the new coordinate of the object."""

import matplotlib.pyplot as plt

# Original triangle coordinates
A = (3, 4)
B = (6, 4)
C = (5, 6)

# Function to reflect a point over the Y-axis
def reflect_y(point):
    x, y = point
    return (-x, y)

A_ref = reflect_y(A)
B_ref = reflect_y(B)
C_ref = reflect_y(C)

original_x = [A[0], B[0], C[0], A[0]]
original_y = [A[1], B[1], C[1], A[1]]

reflected_x = [A_ref[0], B_ref[0], C_ref[0], A_ref[0]]
reflected_y = [A_ref[1], B_ref[1], C_ref[1], A_ref[1]]

plt.figure(figsize=(8, 6))
plt.plot(original_x, original_y, 'b-', label='Original Triangle')
plt.plot(reflected_x, reflected_y, 'r--', label='Reflected Triangle (Y-axis)')

plt.scatter(*zip(A, B, C), color='blue')
plt.scatter(*zip(A_ref, B_ref, C_ref), color='red')

plt.axhline(0, color='black', linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5)
plt.grid(True)
plt.gca().set_aspect('equal', adjustable='box')
plt.legend()
plt.title("Reflection of Triangle Over Y-axis")
plt.show()

"""2D Shearing:

Given a triangle with coordinate points A(1,1), B(0,0), C(1,0) apply the shearing parameter two on X-axis and find out the new coordinate point of the object.
"""

import matplotlib.pyplot as plt

# Original triangle points
A = (1, 1)
B = (0, 0)
C = (1, 0)

# X-axis
shx = 2

# Shearing transformation on X-axis
def shear_x(point, shx):
    x, y = point
    x_new = x + shx * y
    return (x_new, y)

A_sheared = shear_x(A, shx)
B_sheared = shear_x(B, shx)
C_sheared = shear_x(C, shx)

original_x = [A[0], B[0], C[0], A[0]]
original_y = [A[1], B[1], C[1], A[1]]

sheared_x = [A_sheared[0], B_sheared[0], C_sheared[0], A_sheared[0]]
sheared_y = [A_sheared[1], B_sheared[1], C_sheared[1], A_sheared[1]]

plt.figure(figsize=(8, 6))
plt.plot(original_x, original_y, 'bo-', label='Original Triangle')
plt.plot(sheared_x, sheared_y, 'r--o', label='Sheared Triangle (X-axis, shx=2)')

plt.title('Shearing Transformation on X-axis')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.grid(True)
plt.axhline(0, color='black', linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5)
plt.legend()
plt.axis('equal')
plt.show()

print("Original Points:")
print("A =", A, "B =", B, "C =", C)
print("\nSheared Points:")
print("A' =", A_sheared, "B' =", B_sheared, "C' =", C_sheared)

"""Given a triangle with coordinate points A(1,1), B(0,0), C(1,0) apply the shearing parameter two on Y-axis and find out the new coordinate point of the object."""

import matplotlib.pyplot as plt

# Original triangle points
A = (1, 1)
B = (0, 0)
C = (1, 0)

# Y-axis
shy = 2

# Shearing transformation on Y-axis
def shear_y(point, shy):
    x, y = point
    y_new = y + shy * x
    return (x, y_new)

# Apply shearing
A_sheared = shear_y(A, shy)
B_sheared = shear_y(B, shy)
C_sheared = shear_y(C, shy)

original_x = [A[0], B[0], C[0], A[0]]
original_y = [A[1], B[1], C[1], A[1]]

sheared_x = [A_sheared[0], B_sheared[0], C_sheared[0], A_sheared[0]]
sheared_y = [A_sheared[1], B_sheared[1], C_sheared[1], A_sheared[1]]

plt.figure(figsize=(8, 6))
plt.plot(original_x, original_y, 'bo-', label='Original Triangle')
plt.plot(sheared_x, sheared_y, 'g--o', label='Sheared Triangle (Y-axis, shy=2)')

plt.title('Shearing Transformation on Y-axis')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.grid(True)
plt.axhline(0, color='black', linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5)
plt.legend()
plt.axis('equal')
plt.show()

print("Original Points:")
print("A =", A, "B =", B, "C =", C)
print("\nSheared Points:")
print("A' =", A_sheared, "B' =", B_sheared, "C' =", C_sheared)